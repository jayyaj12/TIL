## Array는 어떤 자료구조인가요 ?
Array는 연관된 data를 `메모리상에 연속적이며` 순차적으로 `미리 할당된 크기` 만큼 저장하는 자료구조이다.

## Array 와 Linked List 는 어떤게 다를까 ?
1. 메모리에 저장되는 방식
2. operation의 연산 속도(**삽입, 삭제, 조회**)

### Array의 특징
- 고정된 저장 공간(4byte) -> fixed-size
- 순차적인 데이터 저장(order)

```
int array[4] = {1, 2, 3, 4}
``` 
### Array의 operation들의 time complexity
- 조회(lookup): O(1) - random access 2  
EX) 4의 메모리 주소를 찾을때 첫번째 인덱스의 주소값 + (4 * 3) 을 해서 바로 네번째 인덱스의 주소값으로 이동한다. 
- 마지막 인덱스에 추가(append): O(1)
- 마지막 인덱스에 삭제: O(1)
- 삽입(insert): O(n) -> 데이터를 삽입할 경우 삽입하는 위치 이후의 값들의 주소를 n번 미뤄야한다. 
- 삭제(delete): O(n) -> 데이터를 삭제할 경우 삭제하는 위치 이후의 값들의 주소를 n번 땡겨야한다.
- 탐색(search): O(n) -> 데이터를 탐색할 경우 원하는 값이 나올때까지 주소를 n번 찾아야 한다. 

### Array의 장점
lookup과 append가 빠르다. 따라서 조회를 자주 해야되는 작업에서는 Array 자료구조를 많이 쓴다.

### Array의 단점
fixed-size 특성상 선언시에 Array의 크기를 미리 정해야 하므로 메모리의 낭비나 추가적인 overhead가 발생할 수 있다.  

- __메모리 오버헤드__:  
EX) `int array[10] = {1, 2, 3, 4}` 다음과 같이 Array를 생성하면 40byte 만큼의 크기를 차지하지만 실제 데이터는 16 byte 영역만 차지하므로 24byte 만큼의 메모리가 낭비된다.  

- __시간 오버헤드__:
Array는 중간에 삽입이나 삭제가 일어날 경우 그 뒤에 요소들을 밀거나 당겨야 하므로 작업을 실행하는 동안 시간 오버헤드로 작용한다. 

- __성능 오버헤드__:  
동적 Array를 쓰는 경우 용량을 초과하면 더 큰 배열을 새로 만들고 기존 데이터를 복사해야 하는데 이 복사 작업이 성능 오버헤드이다.

### QUIZ
Q) 미리 예상한 것보다 더 많은 수의 data를 저장하느라 Array의 size가 넘어갔을 경우 어떻게 해결할 수 있을까 ?  
A1) 기존의 Array보다 더 큰 사이즈의 Array를 만들어 기존 Array 데이터를 할당하고 기존 Array는 메모리에서 삭제한다. Dynamic Array 의 예시이다.  
A2) size를 예측하기 쉽지 않다면 Array 대신 Linked list 를 사용하여 데이터가 추가될 때마다 메모리 공간을 할당 받는다. 