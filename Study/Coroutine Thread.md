## 코루틴 이란 ? 
- 코루틴은 경량 스레드(Lightweight Thread) 이다.
- Thread 보다 훨씬 가볍고, 메모리 사용량도 적다.
- 일반 스레드보다 문맥 교환 비용이 거의 없다.
- 중단(suspend)와 재개(resume)이 가능해서 비동기 코드 작성에 적합하다. 

## 코루틴 실행 방식 
코루틴은 디스패쳐(스레드 풀)를 통해 실제 스레드 위에서 실행되며, `suspend` 키워드를 통해 중단과 재개가 가능한 협력형 실행 방식이다.

### 실행 방식 흐름
1. 코루틴 생성: 이 시점에 코루틴 객체가 만들어지고 코루틴 스케줄러에 등록된다.<br>
`launch(Dispachers.Default() {... })`
2. 디스패처가 실행할 스레드 결정
    - `Dispachers.Default`는 내부 스레드 풀에서 하나를 꺼낸다. 
    - 자바의 Thread는 내부적으로 OS 커널 스레드와 1:1 매칭된다. 
    - JVM이 미리 만들어둔 스레드 풀을 사용하기 때문에 실제로는 OS 가 생성하고 진짜 스레드에서 실행되는 것이다. 
3. 코루틴이 스레드 위에서 실행됨
    - 첫줄부터 실행 시작
    - 중간에 `suspend` 함수를 만나면 멈췄다가 조건 맞으면 다시 이어서 실행한다. 
4. 중단과 재개
    - `suspend` 함수는 코루틴을 멈추고, 그 스레드를 다른 일에 재활용한다. 
    - 재개할 때는 다시 적절한 스레드에 붙어서 실행을 계속한다. 

### 코루틴이 Lightweight Thread 라 불리는 이유 ?
코루틴은 스레드처럼 OS의 무거운 지원이 필요없고, 중단/재개가 코틀린 런타임 내부에서 처리되기 때문이다. 
<br>[스레드]
- OS 수준 자원 필요: 스레드를 만들면 OS가 메모리 할당, 스택 공간 구성 등의 작업해줘야함 
- 컨텍스트 스위칭 비용: 스레드 전환마다 CPU 레지스터, 스택, 캐시 전부 교체해야 함 
- 메모리 사용량 큼: 스레드 1개당 기본 스택만 해도 1MB 수준이다. 
- 스레드 수 제한이 있음: 너무 많으면 OutOfMemory 발생. 시스템이 느려진다.

[코루틴]
- OS와 무관: OS가 직접 관리하지 않고, JVM/코틀린 런타임이 관리한다.
- 상태만 보관: 스택 대신 작은 상태 객체만 저장한다(kb 수준)
- 중단/재개 직접 처리: `suspend`는 JVM 바이트코드를 상태머신으로 컴파일해서 처리한다.
- 문맥 전환 빠름: OS 관여가 없고, 메모리 복사나 컨텍스트 전환이 없다.
- 수천 개 생성 가능: 1MB 짜리 스레드 수천개는 위험하지만, 코루틴은 가볍기 때문에 가능하다.

## OS가 관리하지 않고 JVM/코틀린 런타임이 관리한다는 의미
코루틴이 실행될 땐 OS가 만든 스레드에서 동작하지만, 코루틴 자체는 JVM/코틀린 런타임이 상태와 실행 흐름을 직접 관리한다. 
<br>즉 코루틴은 OS에 등록되는 실행 단위가 아닌 JVM 안에서만 살아 있는 "논리적 실행 단위"이다.

## 그렇다면 JVM이 스레드 풀을 관리하는가 ?
결론부터 말하자면 그렇지는 않다. JVM 위에서 돌아가는 코틀린의 코루틴 디스패처와 스케줄러가 스레드 풀을 관리한다. 
```
[OS]  ← 커널 스레드 관리
  ↑
[JVM] ← 자바의 Thread 객체 (= 커널 스레드와 1:1 매핑)
  ↑
[코루틴 디스패처] ← 스레드 풀 만들고 관리
  ↑
[코루틴 런타임] ← 코루틴 스케줄링, suspend/resume 관리
```

## 실제 스레드 풀을 만드는 대상 ?
코틀린의 코루틴 라이브러리는 내부에 CoroutineScheduler라는 걸 갖고 있다..<br>
이게 Dispatchers.Default, Dispatchers.IO 등에 쓰이는 스레드 풀을 생성하고 관리한다.

`val dispatcher = Dispatchers.Default`
이러면 내부적으로는 다음과 같이 동작한다.<br>
- CPU 코어 수 기반으로 최대 N개의 스레드 풀을 생성한다.
- 사용자가 `launch` 하면  그 안에서 작업을 큐에 등록한다.
- CoroutineScheduler가 스레드 풀 내의 스레드를 선택해서 실행한다. 

## JVM 의 역할은 ? 
- 코루틴이 사용하는 스레드는 JVM 이 만든 `Thread` 객체다.
- 하지만 그 위에 "코루틴이 어떻게 동작하고 언제 멈추고 다시 동작하는지"" 는 코루틴 디스패처가 결정한다.
- JVM 은 단지 스레드를 제공해주는 플랫폼 역할을 한다. 

### 코루틴 vs 스레드 비교

| 항목 | 스레드 (Thread) | 코루틴 (Coroutine) |
|------|------------------|----------------------|
| 관리 주체 | OS (운영체제) 수준 | 언어/라이브러리 수준 (ex. Kotlin) |
| 실행 단위 | 독립적인 실행 흐름 (무거움) | 경량 실행 흐름 (가벼움) |
| 생성/종료 비용 | 큼 (메모리 수 MB) | 작음 (수 천 개도 부담 없음) |
| 동시성 처리 | 병렬 실행 (멀티코어 활용) | 협력적 동시성 (suspend/resume) |
| 문맥 전환 | OS가 처리 (Context Switching 비용 큼) | 코루틴 런타임이 직접 처리 (매우 가벼움) |
| 실제 실행 위치 | 직접 CPU 코어에서 실행됨 | 결국은 스레드 위에서 실행됨 |
| 코어 제어 | OS가 스레드를 코어에 배정 | 디스패처가 스레드를 통해 실행 |
| 코드 예시 | `Thread { ... }.start()` | `launch { ... }`, `async { ... }` |
| 사용 목적 | 복잡한 병렬 처리, OS 수준 작업 | 대량의 비동기 작업, UI 처리 등 |
Therad 보다 가벼운 이유
일반 스레드보다 문맥교환 비용이 없는 이유